// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Launcher.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Launcher::Launcher() : Subsystem("Launcher") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftEncoder = RobotMap::launcherleftEncoder;
    rightEncoder = RobotMap::launcherrightEncoder;
    ultrasanic = RobotMap::launcherUltrasanic;
    rightMotor = RobotMap::launcherrightMotor;
    leftMotor = RobotMap::launcherleftMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    table = NetworkTable::GetTable("GRIP/report");
    desiredRate = 0;
}

void Launcher::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

double Launcher::ultrasanicCalculation(){
	double distanceInches; //measures distance from ultrasonic sensor
	double vm = ultrasanic->GetAverageVoltage(); //averge voltage is more accurate and filters out noise
	double mvm = vm * 1000;//converts volts to millivolts
	distanceInches = mvm / 9.375;// this calculation with give inches from surface, sensor must be running at 4.8 volts
	const float filter = 0.5;

	distanceInches = distanceInches + filter * ((mvm / 9.375) - distanceInches); // filters noise
	SmartDashboard::PutNumber("Distance from surface in inches:", distanceInches);
	return distanceInches;

}

void Launcher::launchRight(){
	if(SmartDashboard::GetNumber("Set Launcher Rate", 0) != 0){
		desiredRate = SmartDashboard::GetNumber("Set Launcher Rate", 0);

		SmartDashboard::PutNumber("Desired Rate", desiredRate);
		SmartDashboard::PutNumber("Right Rate", rightEncoder->GetRate());
		SmartDashboard::PutNumber("Left Rate", leftEncoder->GetRate());

		if(rightEncoder->GetRate() < desiredRate){
				rightMotor->Set(0.8);
			}else{
				rightMotor->Set(0.0);
			}
		SmartDashboard::PutNumber("Left Motor Speed", leftMotor->Get());
		SmartDashboard::PutNumber("Right Motor Speed", rightMotor->Get());
	}else{
		std::vector<double> width = table.get()->GetNumberArray("width", 1);
		double newDistance = (1.67 * 240) / (2 * width[0]);
		SmartDashboard::PutNumber("Distance from target", newDistance);

			//desiredRate = newDistance * (-50/.929) + 600; //image processing
			desiredRate = (ultrasanicCalculation() * (-50/37.1)) + 600; // ultrasanic

			//new code to calculate RPM of wheel with distance per pulse at 1, use instead of just rate so kinematics can be used:
			//double leftRPM = (leftEncoder->GetRate() / 360) / 60;
			//double rightRPM = (rightEncoder->GetRate() /360) / 60;

			//desiredRate = sqrt((385.827*(ultrasanicCalculation()^2)) / ultrasanicCalculation - 81 );
			//desiredRate = sqrt((385.827*((newDistance^2) * 39.3701) * cos(45)) / ultrasanicCalculation - 81 ); //give velocity in inches/second, need RPM


			//SmartDashboard::PutNumber("left Rpm", leftRPM);
			//SmartDashboard::PutNumber("right rpm", rightRPM);

			SmartDashboard::PutNumber("Right Rate", rightEncoder->GetRate());
			SmartDashboard::PutNumber("Left Rate", leftEncoder->GetRate());

			SmartDashboard::PutNumber("Desired Rate", desiredRate);

			if(rightEncoder->GetRate() < desiredRate){
				rightMotor->Set(0.8);
			}else{
				rightMotor->Set(0.0);
			}

		SmartDashboard::PutNumber("Left Motor Speed", leftMotor->Get());
		SmartDashboard::PutNumber("Right Motor Speed", rightMotor->Get());
	}
}

void Launcher::launchLeft(){

		if(leftEncoder->GetRate() < desiredRate){
			leftMotor->Set(-0.8);
		}else{
			leftMotor->Set(0.0);
		}

}


void Launcher::stop(){

	leftMotor->Set(0.0);
	rightMotor->Set(0.0);
}

void Launcher::lock(){

	rightMotor->Set(0.42);
	leftMotor->Set(-0.42);

}

void Launcher::unlock(){

	rightMotor->Set(-0.6);
	leftMotor->Set(0.6);

}
