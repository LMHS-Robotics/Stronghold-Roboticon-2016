// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "Launcher.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Launcher::Launcher() : Subsystem("Launcher") {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    leftEncoder = RobotMap::launcherleftEncoder;
    rightEncoder = RobotMap::launcherrightEncoder;
    ultrasanic = RobotMap::launcherUltrasanic;
    rightMotor = RobotMap::launcherrightMotor;
    leftMotor = RobotMap::launcherleftMotor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    //table = NetworkTable::GetTable("GRIP/report");//used for vision distance calculations
    desiredRate = 0;
    distanceCheck = true;
}

void Launcher::InitDefaultCommand() {
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}

// Put methods for controlling this subsystem
// here. Call these from Commands.

double Launcher::ultrasanicCalculation(){//calculations for analog ultrasonic censor for distance to the tower
	double distanceInches; //measures distance from ultrasonic sensor
	double vm = ultrasanic->GetAverageVoltage(); //averge voltage is more accurate and filters out noise
	double mvm = vm * 1000;//converts volts to millivolts
	distanceInches = mvm / 9.375;// this calculation with give inches from surface, sensor must be running at 4.8 volts
	const float filter = 0.5;

	distanceInches = distanceInches + filter * ((mvm / 9.375) - distanceInches); // filters noise
	return distanceInches;

}

void Launcher::launchRight(){



	if(distanceCheck){
		SmartDashboard::PutString("Current Distance Set:", "short distance");
		desiredRate = 500;
		if(rightEncoder->GetRate() < desiredRate){
			rightMotor->Set(0.8);
		}else{
			rightMotor->Set(0.0);
		}
	}else{
		SmartDashboard::PutString("Current Distance Set:", "long distance");
		desiredRate = 400;
		if(rightEncoder->GetRate() < desiredRate){
			rightMotor->Set(0.8);
		}else{
			rightMotor->Set(0.0);
		}
	}



	SmartDashboard::PutNumber("Desired Rate", desiredRate);
	SmartDashboard::PutNumber("Right Rate", rightEncoder->GetRate());
	SmartDashboard::PutNumber("Left Rate", leftEncoder->GetRate());

	/*if(SmartDashboard::GetNumber("Set Launcher Rate", 0) != 0){//checks to see if launcher rate is set manually
		desiredRate = SmartDashboard::GetNumber("Set Launcher Rate", 0);

		SmartDashboard::PutNumber("Desired Rate", desiredRate);
		SmartDashboard::PutNumber("Right Rate", rightEncoder->GetRate());
		SmartDashboard::PutNumber("Left Rate", leftEncoder->GetRate());

		if(rightEncoder->GetRate() < desiredRate){
				rightMotor->Set(0.8);
			}else{
				rightMotor->Set(0.0);
			}
		SmartDashboard::PutNumber("Left Motor Speed", leftMotor->Get());
		SmartDashboard::PutNumber("Right Motor Speed", rightMotor->Get());
	}else{//if rate is not set manually, calculate and run based on distance. distance calculation is a simple linear equation, however kinematics are being tested for better accuracy. Since encoders are not calculating RPM properly, kinematics are not functioning yet
		//std::vector<double> width = table.get()->GetNumberArray("width", 1);
		//double newDistance = (1.67 * 240) / (2 * width[0]);//distance of vision
		//SmartDashboard::PutNumber("Distance from target", newDistance);

			//desiredRate = newDistance * (-50/.929) + 600; //image processing
			desiredRate = (ultrasanicCalculation() * (-50/37.1)) + 600; // ultrasanic

			//new code to calculate RPM of wheel with distance per pulse at 1, use instead of just rate so kinematics can be used:
			double leftRPM = (leftEncoder->GetRate() / 60);
			double rightRPM = (rightEncoder->GetRate() / 60);

			//desiredRate = sqrt((385.827*(ultrasanicCalculation()^2)) / ultrasanicCalculation - 81 );
			//desiredRate = sqrt((385.827*((newDistance^2) * 39.3701) * cos(45)) / ultrasanicCalculation - 81 ); //give velocity in inches/second, need RPM


			SmartDashboard::PutNumber("leftLauncher RPM", leftRPM);
			SmartDashboard::PutNumber("rightLauncher RPM", rightRPM);

			SmartDashboard::PutNumber("Right Rate", rightEncoder->GetRate());
			SmartDashboard::PutNumber("Left Rate", leftEncoder->GetRate());

			SmartDashboard::PutNumber("Desired Rate", desiredRate);

			if(rightEncoder->GetRate() < desiredRate){
				rightMotor->Set(0.8);
			}else{
				rightMotor->Set(0.0);
			}

		SmartDashboard::PutNumber("Left Motor Speed", leftMotor->Get());
		SmartDashboard::PutNumber("Right Motor Speed", rightMotor->Get());
	}*/
}

void Launcher::launchLeft(){//launchRight() does all the calculations

		if(leftEncoder->GetRate() < desiredRate){
			leftMotor->Set(-0.8);
		}else{
			leftMotor->Set(0.0);
		}

}


void Launcher::stop(){

	leftMotor->Set(0.0);
	rightMotor->Set(0.0);
}

void Launcher::lock(){//for running the flywheels slowly to get ball stuck in them for holding the ball

	rightMotor->Set(0.42);
	leftMotor->Set(-0.42);

}

void Launcher::unlock(){//ejects ball back into launching position

	rightMotor->Set(-0.6);
	leftMotor->Set(0.6);

}

void Launcher::changeDistance(bool newDis){
	distanceCheck = newDis;
}
